import { expect, use } from 'chai'
import * as chaiAsPromised from 'chai-as-promised'
import * as t from 'io-ts'
import { createEndpoint } from './createEndpoint'
use(chaiAsPromised)

describe('createEndpoint', () => {
  const addArgs = t.type({
    number1: t.number,
    number2: t.number
  })

  const addState = t.type({
    lastAddition: t.number
  })

  const addEndpoint = createEndpoint<typeof addArgs, typeof t.number, typeof addState>('Add', addArgs, t.number, addState)
  const resolver = ({ number1, number2 }: t.TypeOf<typeof addArgs>) => Promise.resolve(number1 + number2)

  describe('name', () => {
    it('keeps a string reference to the contract endpoint name', () => {
      expect(addEndpoint.name).to.eql('Add')
    })
  })

  describe('call', () => {
    it('throws if arguments are of the wrong type', () => {
      const invalidArgs: any = { number1: 1, number3: 2 }
      return expect(addEndpoint.call(invalidArgs, resolver)).to.eventually.be.rejectedWith(Error)
    })

    it('throws if state is of the wrong type', () => {
      const correctArgs = { number1: 1, number2: 2 }
      const invalidState: any = { someKey: 1 }
      return expect(addEndpoint.call(correctArgs, resolver, invalidState)).to.eventually.be.rejectedWith(Error)
    })

    it('throws if the return type is of the wrong type', () => {
      const correctArgs = { number1: 1, number2: 2 }
      const invalidResolver: any = (_x: t.TypeOf<typeof addArgs>) => Promise.resolve('string')
      return expect(addEndpoint.call(correctArgs, invalidResolver)).to.eventually.be.rejectedWith(Error)
    })

    it('uses the resolver to call the contract', async () => {
      const correctArgs = { number1: 1, number2: 2 }
      const result = await addEndpoint.call(correctArgs, resolver, { lastAddition: 1 })
      expect(result).to.eql(3)
    })
  })

  describe('describe', () => {
    it('returns a string representation of the AST, generated by io-ts', () => {
      const definition = addEndpoint.describe()
      expect(definition.argType).to.eql('{ number1: number, number2: number }')
      expect(definition.returnType).to.eql('number')
      expect(definition.stateType).to.eql('{ lastAddition: number }')
    })
  })

  describe('validateArgs', () => {
    it('throws if args are of an invalid type', () => {
      const invalidArgs: any = { number1: 1, number3: 2 }
      expect(() => addEndpoint.validateArgs(invalidArgs)).to.throw
    })

    it('does not throw if args are of a valid type', () => {
      const validArgs = { number1: 1, number2: 2 }
      expect(() => addEndpoint.validateArgs(validArgs)).to.not.throw
    })
  })

  describe('validateState', () => {
    it('throws if state is of an invalid type', () => {
      const invalidState: any = { someKey: 1 }
      expect(() => addEndpoint.validateState(invalidState)).to.throw
    })

    it('does not throw if state is of a valid type', () => {
      const validState = { lastAddition: 1 }
      expect(() => addEndpoint.validateState(validState)).to.not.throw
    })
  })

  describe('validateReturn', () => {
    it('throws if return value is of an invalid type', () => {
      const invalidReturnVal: any = 'x'
      expect(() => addEndpoint.validateReturn(invalidReturnVal)).to.throw
    })

    it('does not throw if return value is of a valid type', () => {
      const returnValue = 1
      expect(() => addEndpoint.validateReturn(returnValue)).to.not.throw
    })
  })
})
